#!/usr/bin/env python
"""Number spiral diagonals"""
N = 1001


def main():
    """Returns the total sum of diagonals in a number spiral of size N."""
    spiral = NumberSpiral(N)
    # Minus 1 to account for double-counting the central 1
    total = spiral.leading_diagonal + spiral.reverse_diagonal - 1
    return total


class Matrix(object):
    """Represents a matrix."""
    def __init__(self, n_rows, n_columns):
        self.n_rows = n_rows
        self.n_columns = n_columns
        self.matrix = [[None for _ in range(n_columns)] for _ in range(n_rows)]

    @staticmethod
    def _process_indices(indices):
        """Perform sanity checks on the indices we've been given."""
        assert isinstance(indices, tuple), "Indices must be a tuple."
        assert len(indices) == 2, "Exactly two indices required."
        for index in indices:
            assert isinstance(index, int), "Indices must both be integers."
        return indices

    def __getitem__(self, item):
        """Return an item specified by a tuple of (row, col)."""
        row, col = self._process_indices(item)
        return self.matrix[row][col]

    def __setitem__(self, key, value):
        """Set an item in the matrix by specifying its row and column."""
        row, col = self._process_indices(key)
        self.matrix[row][col] = value

    def __iter__(self):
        """Provide read-only access to matrix elements iteratively."""
        for row in range(self.n_rows):
            for col in range(self.n_columns):
                yield self.matrix[row][col]
            yield '\n'

    # The following methods increment row, col in the direction indicated.
    @staticmethod
    def right(row, col):
        return row, col + 1

    @staticmethod
    def down(row, col):
        return row + 1, col

    @staticmethod
    def left(row, col):
        return row, col - 1

    @staticmethod
    def up(row, col):
        return row - 1, col

    @property
    def leading_diagonal(self):
        """Sum the leading diagonal of a square matrix."""
        col = 0

        def increase(x):
            return x + 1

        sum_diags = self.base_diagonal(col, increase)
        return sum_diags

    @property
    def reverse_diagonal(self):
        """Sum the reverse diagonal of a square matrix."""
        col = N - 1

        def decrease(x):
            return x - 1

        sum_diags = self.base_diagonal(col, decrease)
        return sum_diags

    def base_diagonal(self, col, increment):
        """Base method to sum either diagonal of a square matrix."""
        row = 0
        sum_diags = 0
        while row < N:
            sum_diags += self[row, col]
            row += 1
            col = increment(col)
        return sum_diags


class NumberSpiral(Matrix):
    """
    Represents a number spiral, a special type of matrix whose members are
    autogenerated in a clockwise spiral pattern, starting from 1 in the centre
    and incrementing up to a maximum value of n^2.
    """

    def __init__(self, n):
        assert n % 2 != 0, "Spirals can only be formed in odd size matrices."
        self.n = n
        super(NumberSpiral, self).__init__(n, n)
        self.directions = [self.right, self.down, self.left, self.up]
        self._fill_spiral()

    def _fill_spiral(self):
        """
        Fill the matrix with a spiral pattern of numbers, starting from 1 in
        the centre and spiralling out clockwise.
        """
        # start from the centre of the spiral
        row = int(self.n / 2)
        col = row
        # start filling with the number 1
        i = 1
        # we will fill numbers up to n^2
        limit = self.n ** 2
        # the following are used to decide which direction to move in each step
        self.steps = 1
        self.steps_taken = 0
        self.dir_index = 0

        # now fill the matrix!
        while i <= limit:
            self.matrix[row][col] = i
            row, col = self._move(row, col)
            i += 1

    def _move(self, row, col):
        """
        Decide which direction to move in and increment row and column indices
        appropriately. Every two movements the step length increments and after
        every step the direction changes.
        """
        if self.steps_taken == self.steps:
            self.dir_index = (self.dir_index + 1) % 4
            self.steps_taken = 0
            if self.dir_index % 2 == 0:
                self.steps += 1
        self.steps_taken += 1
        return self.directions[self.dir_index](row, col)


if __name__ == '__main__':
    print main()
