#!/usr/bin/env python3
"""Number spiral diagonals"""
import numpy as np
import directions

N = 1001


def main():
    """Returns the total sum of diagonals in a number spiral of size N."""
    spiral = NumberSpiral(N)

    # Sum both leading and reverse diagonals. Minus 1 to account for
    # double-counting the central 1.
    total = spiral.leading_diagonal + spiral.reverse_diagonal - 1
    return total


class NumberSpiral(object):
    """
    Represents a number spiral, a special type of matrix whose members are
    autogenerated in a clockwise spiral pattern, starting from 1 in the centre
    and incrementing up to a maximum value of n^2.
    """

    def __init__(self, n):
        assert n % 2 != 0, "Spirals can only be formed in odd size matrices."
        self.n = n
        self.directions = (
            directions.right, directions.down, directions.left, directions.up)
        self.matrix = np.matrix([[None for _ in range(n)] for _ in range(n)])
        self._fill_spiral()

    def _fill_spiral(self):
        """
        Fill the matrix with a spiral pattern of numbers, starting from 1 in
        the centre and spiralling out clockwise.
        """
        # start from the centre of the spiral
        row = int(self.n / 2)
        col = row
        # start filling with the number 1
        i = 1
        # we will fill numbers up to n^2
        limit = self.n ** 2
        # the following are used to decide which direction to move in each step
        self.steps = 1
        self.steps_taken = 0
        self.dir_index = 0

        # now fill the matrix!
        while i <= limit:
            self.matrix[row, col] = i
            row, col = self._move(row, col)
            i += 1

    def _move(self, row, col):
        """
        Decide which direction to move in and increment row and column indices
        appropriately. Every two movements the step length increments and after
        every step the direction changes.
        """
        if self.steps_taken == self.steps:
            self.dir_index = (self.dir_index + 1) % 4
            self.steps_taken = 0
            if self.dir_index % 2 == 0:
                self.steps += 1
        self.steps_taken += 1
        return self.directions[self.dir_index](row, col)

    @property
    def leading_diagonal(self):
        """Sum the leading diagonal of a square matrix."""
        col = 0

        def increase(x):
            return x + 1

        sum_diags = self.base_diagonal(col, increase)
        return sum_diags

    @property
    def reverse_diagonal(self):
        """Sum the reverse diagonal of a square matrix."""
        col = N - 1

        def decrease(x):
            return x - 1

        sum_diags = self.base_diagonal(col, decrease)
        return sum_diags

    def base_diagonal(self, col, increment):
        """Base method to sum either diagonal of a square matrix."""
        row = 0
        sum_diags = 0
        while row < N:
            sum_diags += self.matrix[row, col]
            row += 1
            col = increment(col)
        return sum_diags


if __name__ == '__main__':
    print(main())

